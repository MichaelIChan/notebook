# 15.1 引言
进程间通信（InterProcess Communication, IPC）是进程之间相互通信的技术。<br>
# 15.2 管道
管道是UNIX系统IPC的最古老形式。管道有两种局限性。<br>
* 有的系统仅提供半双工通道（FIFO，即数据只能在一个方向上流动）。<br>
* 管道只能在具有公共祖先的两个进程之间使用。通常，一个管道由一个进程创建，在进程调用fork之后，这个管道就能在父进程和子进程之间使用了。<br>

每当在管道中键入一个命令的序列，让shell执行时，shell都会为每一条命令单独创建一个进程，然后用管道将前一条命令进程的标准输出与后一条命令的标准输入相连接。<br>

管道是通过调用 `pipe` 函数创建的。<br>
```c++
#include <unistd.h>
int pipe(int fd[2]);
// 返回值：若成功，返回 0；若出错，返回 -1
```
经由参数`fd`返回两个文件描述符：`fd[0]`为读而打开，`fd[1]`为写而打开。`fd[1]`的输出是`fd[0]`的输入。<br>

单个进程中的管道几乎没有任何用处。通常，进程会先调用`pipe`，接着`fork`，从而创建从父进程到子进程的IPC通道。<br>

`fork`之后做什么取决于我们想要的数据流的方向。对于从父进程到子进程的管道，父进程关闭管道的读端`fd[0]`，子进程关闭写端`fd[1]`。子进程到父进程的管道与之相反。<br>

当管道一端被关闭后，下列两条规则起作用。<br>
1. 当读一个写端已被关闭的管道时，在所有数据都被读取后，`read`返回 0，表示文件结束。<br>
2. 当写一个读端已被关闭的管道时，则产生信号`SIGPIPE`。如果忽略该信号或者捕捉该信号并从其信号处理程序返回，则`write`返回 −1，`errno`设置为`EPIPE`。<br>

在写管道（或FIFO）时，常量`PIPE_BUF`规定了内核的管道缓冲区大小。如果对管道调用`write`，而且要求写的字节数小于等于`PIPE_BUF`，则此操作不会与其他进程对同一管道（或FIFIO）的`write`操作交叉进行。但是，若有多个进程同时写一个管道（或FIFO），而且我们要求写的字节数超过`PIPE_BUF`，那么我们所写的数据可能会与其他进程所写的数据相互交叉。用`pathconf`或`fpathconf`函数可以确定`PIPE_BUF`的值。<br>
# 15.3 函数 popen 和 pclose
常见的操作是创建一个连接到另一个进程的管道，然后读其输出或向其输入发送数据，为此，标准I/O库提供了两个函数`popen`和`pclose`。这两个函数实现的操作是：创建一个管道，`fork`一个子进程，关闭未使用的管道端，执行一个shell运行命令，然后等待命令终止。<br>
```c++
#include <stdio.h>
FILE *popen(const char *cmdstring, const char *type);
// 返回值：若成功，返回文件指针；若出错，返回 NULL
int pclose(FILE *fp);
// 返回值：若成功，返回 cmdstring 的终止状态；若出错，返回 -1
```
函数`popen`先执行`fork`，然后调用`exec`执行`cmdstring`，并且返回一个标准I/O文件指针。如果`type`是“`r`”，则文件指针连接到`cmdstring`的标准输出；如果`type`“`w`”，则文件指针连接到`cmdstring`的标准输入。<br>

`pclose`函数关闭标准I/O流，等待命令终止，然后返回shell的终止状态。如果shell不能执行，则`pclose`返回值的终止状态与shell已经执行`exit(127)`一样。<br>
# 15.4 协同进程
过滤程序从标准输入读取数据，向标准输出写数据。几个过滤程序通常在shell管道中线性连接。当一个过滤程序既产生某个过滤程序的输入，又读取该过滤程序的输出时，它就变成了协同进程（coprocess）。<br>
# 15.5 FIFO
`FIFO`有时被称为命名管道。未命名的管道只能在两个相关的进程之间使用，而且这两个相关进程还要有一个共同创建了它们的祖先进程。但是，通过FIFO，不相关的进程也能交换数据。<br>

FIFO 是一种文件类型。通过`stat`结构的`st_mode`成员的编码库知道文件是否是FIFO类型。可以用`S_ISFIFO`宏对此进行测试。创建FIFO类似于创建文件。<br>
```c++
#include <sys/stat.h>
int mkfifo(const char *path, mode_t mode);
int mkfifoat(int fd, const char *path, mode_t mode);
// 返回值：若成功，返回 0；若出错，返回 -1
```
`mkfifo`函数中的 `mode` 参数的规格说明与 `open` 函数中 `mode` 的相同。<br>

`mkfifoat`函数和`mkfifo`函数相似，但是`mkfifoat`函数可以被用来在`fd`文件描述符表示的目录相关的位置创建一个FIFO。像其他`*at`函数一样，这里有三种情形。<br>
1. 如果`path`参数指定的是绝对路径名，则`fd`参数会被忽略掉，并且`mkfifoatt`函数的行为和`mkfifo`类似。<br>
2. 如果`path`参数指定的是相对路径名，则`fd`参数是一个打开目录的有效文件描述符，路径名和目录有关。<br>
3. 如果`path`参数指定的是相对路径名，并且`fd`参数有一个特殊值`AT_FDCWD`，则路径名以当前目录开始，`mkfifoat`和`mkfifo`类似。<br>

当用`mkfifo`或者`mkfifoat`创建FIFO时，要用`open`来打开它。<br>

当`open`一个FIFO时，非阻塞标志（`O_NONBLOCK`）会产生下列影响。<br>
* 在一般情况下（没有指定`O_NONBLOCK`），只读`open`要阻塞到某个进程为写而打开这个FIFO为止 。类似地，只写`open`要阻塞到某个其他进程为读而打开它为止。<br>
* 如果指定了`O_NONBLOCK` ，则只读`open`立即返回 。但是，如果没有进程为读而代开一个FIFO，那么只写`open` 将返回 −1 ，并将`errno`设置成`ENXIO`。<br>

若`write`一个尚无进程为读而打开的FIFO，则产生信号`SIGPIPE`。若某个FIFO的最后一个写进程关闭了该FIFO，则将为该FIFO的读进程产生一个文件结束标志。<br>

一个给定的FIFO有多个写进程是常见的，如果不希望多个进程所写的数据交叉，则必须考虑原子写操作。和管道一样，常量`PIPE_BUF`说明了可被原子地写到FIFO的最大数据量。FIFO有以下两种用途。<br>

1. shell 命令使用 FIFO 将数据从一条管道传送到另一条时，无需创建中间临时文件。
2. 客户进程-服务器进程 应用程序中，FIFO 用作汇聚点，在客户进程和服务器进程二者之间传递数据。<br>

# 15.6 XSI IPC
## 15.6.1 标识符和键
## 15.6.2 权限结构
## 15.6.3 结构限制
## 15.6.4 优点和缺点
# 15.7 消息队列
# 15.8 信号量
# 15.9 共享存储
# 15.10 POSIX 信号量
# 15.11 客户进程-服务器进程属性