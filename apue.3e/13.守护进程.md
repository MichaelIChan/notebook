# 13.1 引言
守护进程(daemoon)是生存期长的一种进程。常常在系统引导装入时启动，仅在系统关闭时才终止。因为它们没有控制终端，所以说它们是在后台运行的。UNIX有很多守护进程，它们执行日常事务活动。<br>
# 13.2 守护进程的特征
父进程ID为0的各进程通常是内核进程，它们作为系统引导装入过程的一部分而启动。（`init`是个例外，它是一个由内核在引导装入时启动的用户层次的命令。）内核进程是特殊的，通常存在于系统的整个生命期中。它们以超级用户权限运行，无控制终端，无命令行。<br>

linux使用一个名为`kthreadd`的特殊内核进程来创建其他内核进程，所以`kthreadd`表现为其他内核进程的父进程。对于需要在进程上下文执行工作但却不被用户层进程上下文调用的每一个内核组件，通常有自己的内核守护进程。<br>

`init`进程是一个系统守护进程，主要负责启动各运行层次特定的系统服务。`init`进程启动的系统服务通常是在它们自己拥有的守护进程的帮助下实现的，用户层守护进程的父进程是`init`进程。<br>

注意，大多数守护进程都是以超级用户（root）特权运行。所有守护进程都没有控制终端，其控制终端名设置为问号。内核守护进程以无控制终端方式启动。用户层守护进程缺少控制终端可能是守护进程调用了`setsid`的结果。大多数用户层守护进程都是进程组的组长进程以及会话的首进程，而且是这些进程组和会话中的唯一进程（`rsyslogd`是个例外）。<br>
# 13.3 编程规则
编写守护进程程序需遵循一些基本规则，以防止产生不必要的交互作用。<br>
1. 调用`umask`将文件模式创建屏蔽字设置为一个已知值（通常是0）。因为由继承得来的文件模式创建屏蔽字可能会被设置为拒绝某些权限，而如果守护进程要创建文件，那么它可能要设置特定的权限。<br>
2. 调用`fork`，然后使父进程`exit`。这样做实现了下面几点：第一，如果该守护进程是作为一条`shell`命令启动的，那么父进程终止会让`shell`认为这条命令已经执行完毕，`shell`可以执行其他命令，形式上做到了守护进程与终端控制的脱离。第二，虽然子进程继承了父进程进程组ID，但获得了新的进程ID，这就保证了子进程不是一个进程组的组长进程（使用`setsid`的先决条件）<br>
3. 调用`setsid`创建一个新会话。使调用进程：成为新会话首进程，成为一个新进程组的组长进程，没有控制终端。（在此可再次调用`fork`，终止父进程，继续使用子进程中的守护进程，保证该守护进程不是会话首进程。）<br>
4. 将当前工作目录更改为根目录。因为从父进程继承过来的当前工作目录可能在一个挂载的文件系统中。守护进程通常在系统再引导之前是一直存在的，守护进程随系统存在的特性使得此文件系统不能被卸载。也可以将当前工作目录更改到某个指定位置。<br>
5. 关闭不需要的文件描述符。这使守护进程不再持有从其父进程继承来的任何文件描述符。<br>
6. 某些守护进程打开 /dev/null 使其具有文件描述符0、1和2，这样任何一个试图读标准输入、写标准输出或标准错误的库例程都不会产生任何效果。（因为守护进程并不与终端设备相关联）。<br>
# 13.4 出错记录
守护进程存在的一个问题是如何处理出错消息。因为它本就不应该有控制终端，所以不能只是简单地写到标准错误上。<br>

有以下3种产生日志消息的方法：<br>
1. 内核例程可以调用`log`函数。任何一个用户进程都可以通过打开（`open`）并读取（`read`）`/dev/klog`设备来读取这些消息。<br>
2. 大多数用户进程（守护进程）调用`syslog(3)`函数来产生日志消息。这使消息被发送至UNIX域数据报套接字`/dev/log`。<br>
3. 无论一个用户是在此主机上，还是在通过TCP/IP网络连接到此主机的其他主机上，都可将日志消息发向UDP端口514。注意，`syslog`函数从不产生这些UDP数据报，它们要求产生此日志消息的进程进行显示的网络编程。<br>

通常，`syslogd`守护进程读取所以3种格式的日志消息。此守护进程在启动时读一个配置文件，其文件名一般为`/etc/syslog.conf`，该文件决定了不同种类的消息应送向何处。<br>

该设施的接口是`syslog`函数。
```c++
#include <syslog.h>
void openlog(const char *ident, int option, int facility);
void syslog(int priority, const char *format, ...);
void closelog(void);
int setlogmask(int maskpri);
```
调用`openlog`是可选择的。如果不调用`openlog`，则在第一次调用`syslog`时，自动调用`openlog`。调用`closelog`也是可选择的，因为它只是关闭层被用于与`syslogd`守护进程进行通信的描述符。<br>

调用`openlog`使我们可以指定一个`ident`，以后，此`ident`将被加至每则日志消息中。`ident`一般是程序的名称。`option`参数是指定各种选项的位屏蔽。<br>

`openlog`的`option`参数：
| option     | XSI  | 说明|
|:----------:|:----:|:--------------------------------------------------------:|
| LOG_CONS   | ·    | 若日志消息不能通过UNIX域数据报送至`syslogd`，则将该消息写至控制台 |
| LOG_NDELAX | ·    | 立刻打开至`syslogd`守护进程的UNIX域数据报套接字，不要等到第一条消息已经被记录时再打开。通常，在记录第一条消息之前，不打开该套接字 |
| LOG_NOWAIT | ·    | 不要等待在将消息记入日志过程中可能已创建的子进程。因为在`syslog`调用`wait`时，应用程序可能已获得了子进程的状态，这种处理阻止了与捕捉`SIGCHLD`信号的应用程序之间产生的冲突。 |
| LOG_ODELAY | ·    | 在第一条消息被记录之前延迟打开至`syslogd`守护进程的连接 |
| LOG_PERROR |      | 除将日志消息发送给`syslogd`以外，还将它写至标准出错 |
| LOG_PID    | ·    | 记录每条消息都要包含进程ID。此选项可供对每个不同的请求都`fork`一个子进程的守护进程使用（与从不调用`fork`的守护进程相比较，如`syslogd`） |
# 13.5 单实例守护进程
为了正常运作，某些守护进程会实现为：在任一时刻只运行该守护进程的一个副本。例如，这种守护进程可能需要排他地访问一个设备。<br>

文件和记录锁机制为保证一个守护进程只有一个副本在运行提供了基础。如果一个守护进程创建一个有固定名字的文件，并在该文件的整体上加一把写锁，那么只允许创建一把这样的写锁。在此之后创建写锁的尝试都会失败，这向后续守护进程副本指明已有一个副本在运行。<br>
# 13.6 守护进程的惯例
在UNIX系统中，守护进程遵循下列通用惯例。
* 若守护进程使用锁文件，那么该文件通常存储在`/var/run`目录中。然而需要注意的是，守护进程可能需要具有超级用户权限才能在此目录下创建文件。锁文件的名字通常是`name.pid`，其中，`name`是该守护进程或服务的名字。<br>
* 若守护进程支持配置选项，那么配置文件通常存放在`/etc`目录中。配置文件的名字通常是`name.conf`。<br>
* 守护进程可用命令行启动，但通常它们是由系统初始化脚本之一（`/etc/rc*`或`/etc/init.d/*`）启动的。如果在守护进程终止时，应当自动地重新启动它，则我们可在`/etc/inittab`中为该守护进程包括`respawn`记录项，这样，`init`就将重新启动该守护进程。（假定系统使用System V风格的`init`命令。）<br>
* 若一个守护进程有一个配置文件，那么当该守护进程启动时会读该文件，但在此之后一般就不会再查看它。若某个管理员更改了配置文件，那么该守护进程可能需要被停止，然后再启动，以使配置文件的更改生效。为避免此种麻烦，某些守护进程将捕捉`SIGHUP`信号，当它们接收到该信号时，重新读配置文件。守护进程可以安全地重复使用`SIGHUP`。<br>
# 13.7 客户进程-服务器进程模型
守护进程常常用作服务器进程。例如，`syslogd`进程为服务器进程，用户进程（客户进程）用UNIX域数据报套接字向其发送消息。<br>

一般而言，服务器进程等待客户进程与其联系，提出某种类型的服务要求。例如，`syslogd`服务器进程提供的服务是将一条出错消息记录到日志文件中。<br>

客户进程和服务器进程之间的通信是单向的，客户进程向服务器进程发送服务请求，服务器进程则不向客户进程回送任何消息。<br>

在服务器进程中调用`fork`然后`exec`另一个程序来向客户进程提供服务是很常见的。这些服务器进程通常管理着多个文件描述符：通信端点、配置文件、日志文件和类似的文件。最好的情况下，让子进程中的这些文件描述符保持打开状态并无大碍，因为它们很可能不会被在子进程中执行的程序所使用，尤其是那些与服务器端无关的程序。最坏情况下，保持它们的打开状态会导致安全问题——被执行的程序可能有一些恶意行为，如更改服务器端配置文件或欺骗客户端程序使其认为正在与服务器端通信，从而获取未授权的信息。<br>

解决此问题的一个简单方法是对所有被执行程序不需要的文件描述符设置执行时关闭（close-on-exec）标志。下面展示了一个可以用来在服务器端进程中执行上述工作的函数。<br>
```c++
#include "apue.h"
#include <fcntl.h>

int set_cloexec(int fd)
{
    int    val;

    if ((val = fcntl(fd, F_GETFD, 0)) < 0)
        return(-1);

    val |= FD_CLOEXEC;        // enable close-on-exec

    return(fcntl(fd, F_SETFD, val));
}
```