## 条款19：设计class犹如设计type
* 新type的对象应的创建和销毁。这会影响到构造函数和析构函数以及内存分配函数和释放函数的设计。
* 对象的初始化和对象的赋值的差别。这决定了构造函数和赋值操作符的行为，以及其间的差异。重要的是不能混淆“初始化”和“赋值”，因为它们对应于不同的函数调用（条款4）。
* 新type的对象以值传递的方法进行参数传递。copy构造函数用来定义一个type的值传递方式如何实现。
* 新type的合法值。对class的成员变量而言，通常只有某些数值集合是有效的。那些数值决定了class必须维护的约束条件，也决定了成员函数必须进行的错误检查工作，也影响函数的异常处理。
* 新type需要配合某个继承体系。type继承自哪些既有的类，那type就受到那些类的设计的舒服，特别是受到virtual或non-virtual的影响（条款34，条款36）。如果允许其他类继承这个type，那还会影响这个type所声明的函数，例如是否需要声明析构函数为virtual（条款7）。
* 新的type所需要的类型转换。如果允许类型T1的对象被隐式转换为类型T2的对象，就必须在类T1内包含一个类型转换函数（operator T2）或在类T2内写一个non-explicit-one-argument（可以被单一实参调用）的构造函数。如果只允许explicit构造函数存在，就得写出专门执行转换的函数，且不能为类型转换操作符（operator）或non-explicit-one-argument构造函数（条款15）。
* 对新type而言合理的操作符和函数。这会决定将为类声明哪些函数。（条款23，24，26）。
* 应当被驳回的标准函数。这些正是被声明为private的成员（条款6）。
* 访问新type的成员。这决定了哪个成员为public，哪个为protected，哪个为private。也决定了哪个类或函数应该是friends，以及将它们嵌套于另一个之内是否合理。
* 新type的未声明接口。它对效率/异常安全性（条款29）以及资源运用（例如多任务锁定和动态内存）提供了保证，在这些方面提供的保证将为类的实现代码加上相应的约束条件。
* 新type的一般化。或许不该定义一个新类，而是定义一个新的类模板。
* 新type的必要性。如果只是定义新的派生类以便为既有的类添加功能，那也许单纯定义一个或多个非成员函数或模板，更能达到这个目标。