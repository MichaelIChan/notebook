# 7.6 类的静态成员
类的静态成员与类本身直接相关，而不是与类的各个对象保持关联。<br>
### 声明静态成员
通过在成员的声明之前加上关键字`static`使得其与类关联在一起。静态成员可以是`public`或`private`。静态数据成员可以是常量、引用、指针类类型等。<br>
静态成员函数同样不与任何对象绑定，不包含`this`指针。静态成员函数不能声明为`const`，也不能在静态成员函数体内使用`this`指针，这包括了显式使用和隐式使用。<br>
### 使用类的静态成员
使用类的对象、引用或者指针，通过作用域运算符直接访问静态成员。<br>
### 定义静态成员
既可以在类的内部也可以在类的外部定义静态成员函数。当在类的外部定义静态成员时，不能使用`static`关键字。<br>
因为静态数据成员不属于类的任何一个对象，所以它们并不是在创建类的对象时被定义的。这意味着它们不是由类的构造函数初始化的。一般来说，不能在类的内部初始化静态成员，必须在类的外部定义和初始化每个静态成员。<br>
类似于全局变量，静态数据成员定义在任何函数之外，一旦被定义，将一直存在于程序的整个声明周期中。<br>
### 静态成员的类内初始化
可以为静态成员提供`const`整数类型的类内初始值，要求静态成员必须是字面值常量类型的`constexpr`。初始值必须是常量表达式，因为这些成员本事就是常量表达式。<br>
即使一个常量静态数据成员在类内部被初始化了，通常情况下也应该在类的外部定义一下该成员<br>
```c++
// 一个不带初始值的静态成员的定义
constexpr int Account::period;  // 初始值在类的定义内提供
```
### 静态成员能用于某些场景，而普通成员不能
静态数据成员可以是不完全类型。特别的，静态数据成员的类型可以就是它所属的类类型，而非静态数据成员只能声明成它所属类的指针或引用。<br>
静态成员和普通成员的另外一个区别是，可以使用静态成员作为默认实参：<br>
```c++
class Screen {
public:
    // bkground 表示一个在类中稍后定义的静态成员
    Screen& clear(char = bkground);
private:
    static const char bkground;
};
```
非静态数据成员不能作为默认实参，因为它的值本身属于对象的一部分，这么做的结果是无法真正提供一个对象以便从中获取成员的值，最终将引发错误。<br>