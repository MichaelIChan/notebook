# 2.4 const 限定符
`const`对象一旦创建后其值就不能再改变，所以`const`对象必须初始化。<br>
### 默认状态下，`const`对象仅在文件内有效<br>
编译器将在编译过程中把用到该变量的地方都替换成对应的值。当多个文件中出现了同名的`const`变量时，等同于在不同文件中分别定义了独立的变量。<br>
某些时候我们希望只在一个文件中定义`const`变量，而在其他多个文件中声明并使用它，解决办法是，对于`const`变量不管是声明还是定义都添加`extern`关键字。<br>
## 2.4.1 const 的引用
把引用绑定到`const`对象上，称之为**对常量的引用**。对常量的引用不能被用作修改它所绑定的对象。引用的对象是常量还是非常量可以决定其所能参与的操作，但是不会影响到引用和对象的绑定关系本身。<br>
### 初始化和对`const`的引用
一般情况下，引用的类型必须与其所引用对象的类型一致，但是有两个例外。第一种例外情况就是在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。例如：<br>
```c++
double dval = 3.14;
const int &ri = dval;
```
此处`ri`引用了一个`int`型的数，`dval`却是一个`double`型。因此为了确保让`ri`绑定一个整数，编译器把上述代码变成了如下形式：
```c++
const int temp = dval;
const int &ri = temp;
```
这种情况下，`ri`实际上绑定了一个临时对象。如果`ri`不是常量，就允许对`ri`赋值，这样就会改变`ri`所引用对象的值。注意，此时绑定的对象是一个临时量而非`dval`，故实际改变的是临时量而不是`dval`的值。这显然不符合预期行为，故C++把这种行为归位非法。<br>
### 对`const`的引用可能引用一个并非`const`的对象
常量引用仅对引用可参与的操作做出了限定，对于引用的对象本身是不是一个常量未作限定。对象可以是个非常量，允许通过其他途径改变它的值。
## 2.4.2 指针和 const
类似于常量引用，**指向常量的指针**不能用于改变其所指对象的值。允许令一个指向常量的指针指向一个非常量对象。<br>
### const 指针
指针是对象而引用不是。**常量指针**必须初始化，初始化后，其值（也就是存放在指针中的地址）就不能再改变了。<br>
## 2.4.3 顶层 const
用名词**顶层const**来表示指针本身是个常量，而用名词**底层const**表示指针所指的对象是一个常量。<br>
更一般的，顶层`const`可以表示任意的对象本身是常量，这对任何数据类型都适用，指针类型既可以是顶层`cons`t也可以是底层`const`。<br>
在执行拷贝操作时，顶层const不受影响，因为拷贝操作不会改变被拷贝对象的值。底层const有一定限制，拷入和拷出的对象必须具有相同的底层const资格，或者两个对象的数据类型能够转换，及非常量转换成常量。<br>
## 2.4.4 constexpr 和常量表达式
**常量表达式**是指值不会改变并且在编译过程就能得到计算结果的表达式。<br>
### constexpr 变量
在一个复杂系统中，很难分辨一个初始值是不是常量表达式。C++11标准规定，允许将变量声明为**constexpr**类型以便由编译器来验证变量的值是否是一个常量表达式。不能使用普通函数作为`constexpr`变量的初始值，但是C++11标准允许定义一种特殊的足够简单的`constexpr`函数，以使其在编译时就可以计算其结果，这样就能用该`constexpr`函数去初始化`constexpr`变量。<br>
一般来说，如果认定某个变量是一个常量表达式，那就应该把它声明成`constexpr`类型。<br>
### 字面值类型
算术类型、引用和指针都属于字面值类型；自定义类、IO库、string类型不属于字面值类型，不能被定义成`constexpr`。<br>
指针和引用都能定义成`constexpr`，但初始值受到严格限制。一个`constexpr`指针但初始值必须是`nulptr`或者0，或者是存储于某个固定地址中的对象。函数体内定义的变量一般来说并非存放在固定地址中，因此`constexpr`指针不能指向这样的变量。<br>
### 指针和 constexpr
如果在`constexpr`声明中定义了一个指针，限定符`constexpr`仅对指针有效，与指针所指的对象无关：
```c++
const int *p = nullptr;     // p 是一个指向整型常量的指针
constexpr int *q = nullptr; // q 是一个指向整数的常量指针
```
### constexpr 和 const
C++11标准中，为了解决`const`关键字的双重语义问题，保留了`const`表示“只读”的语义，而将“常量”的语义划分给了新添加的`constexpr`关键字。因此C++11标准中，建议将`const`和`constexpr`的功能区分开，即凡是表达“只读”语义的场景都使用`const`，表达“常量”语义的场景都使用 `constexpr`。<br>