# 8.1 IO类
## 8.1.1 IO对象无拷贝或赋值
不能拷贝或对IO对象赋值，因此也不能将形参或返回类型设置为流类型。进行IO操作的函数通常以引用方式传递和返回流。读写一个ID对象会改变其状态，因此传递和返回的引用不能是`const`的。<br>
## 8.1.2 条件状态
IO库条件状态：
| 操作 | 说明 |
| :----: | :----: |
| strm::iostate | strm是一种IO类型。iostate是一种机器相关的类型，提供了表达条件状态的完整功能 |
| strm::badbit | strm::badbit用来指出流已崩溃 |
| strm::failbit | strm::failbit用来指出一个IO操作失败了 |
| strm::eofbit) | strm::eofbit用来指出流到达了文件结束 |
| strm::goodbit | strm::goodbit用来指出流未处于错误状态。此值保证为零 |
| s.eof() | 若流s的eofbit置位，则返回true |
| s.fail() | 若流s的failbit或badbit置位，则返回true |
| s.bad() | 若流的badbit置位，则返回true |
| s.good() | 若流s处于有效状态，则返回true |
| s.clear() | 将流s中所有条件状态位复位，将流的状态设置为有效，返回void |
| s.clear(flags) | 根据给定的flags标志位，将流s中对应条件状态位复位。flags的类型为strm::iostate。返回void |
| s.setstate(flags) | 根据给定的flags标志位，将流s中对应条件状态位复位。flags的类型为strm::iostate。返回void |
| s.rdstate() | 返回流s的当前条件状态，返回值类型为strm::iostate |

一个流一旦发生错误，其后续的IO操作都会失败。<br>
### 查询流的状态
IO库定义了一个与机器无关的`iostate`类型，提供了表达流状态的完整功能。IO库定义了4个`iostate`类型的`constexpr`值表示特定的位模式。<br>
`badbit`表示系统级错误，如不可恢复的读写错误，一旦被置位，流无法再使用。`failbit`表示可恢复错误，如期望读取数据却读出一个字符。问题修正后，流可继续使用。如果达到文件结束位置，`eofbit`和`failbit`都会被置位。`goodbit`的值为0，表示流未发生错误。如果`badbit`、`failbit`和`eofbit`任一个被置位，则检测流状态的条件会失败。<br>
## 8.1.3 管理输出缓冲
每个输出流都管理一个缓冲区，用来保存程序读写的数据。有了缓冲机制，操作系统就可以将程序的多个输出操作组合成单一的系统级写操作，以带来性能提升。<br>
导致缓冲刷新（即数据真正写到输出设备或文件）的原因有很多：
* 程序正常结束，作为`main`函数的`return`操作的一部分，缓冲刷新被执行。
* 缓冲区满时，需要刷新缓冲，而后新的数据才能继续写入缓冲区。
* 使用操作符`endl`来显式刷新缓冲区。
* 在每个输出操作之后，可以用操作符`unitbuf`设置流的内部状态，来清空缓冲区。默认情况下，对`cerr`是设置`unitbuf`的，因此写到`cerr`的内容都是立即刷新的。
* 一个输出流可能被关联到另一个流。当读写被关联的流时，关联到的流的缓冲区会被刷新。默认情况下，`cin`和`cerr`都关联到`cout`，因此读`cin`或写`cerr`都会导致`count`的缓冲区被刷新。
### 刷新输出缓冲区
除了`endl`，IO库中还有两个类似操作符可以刷新缓冲区：`flush`和`ends`。`flush`刷新缓冲区，但不输出任何额外的字符；`ends`向缓冲区插入一个空字符，然后刷新缓冲区。<br>
### unitbuf 操作符
`unitbuf`操作符告诉流在接下来的每次写操作之后都进行一次`flush`操作。`nounitbuf`操作符重置流，使其恢复使用正常的系统管理的缓冲区刷新机制。<br>
```
警告：如果程序崩溃，输出缓冲区不会被刷新
```
### 关联输入和输出流
当一个输入流被关联到一个输出流时，任何试图从输入流读取数据的操作都会先刷新关联的输出流。<br>
```
Note:
交互式系统通常应该关联输入流和输出流
```
`tie`有两个重载的版本：一个版本不带参数。返回指向输出流的指针。如果本对象当前关联到一个输出流，则返回的就是指向这个流的指针，如果对象为关联到流，则返回空指针。tie的第二个版本接受一个指向`ostream`的指针，将自己关联到此`ostream`。<br>
既可以将一个`istream`对象关联到另一个`ostream`，也可以将一个`ostream`关联到另一个`ostream`。每个流同时最多关联到一个流，但多个流可以同时关联到同一个`ostream`<br>