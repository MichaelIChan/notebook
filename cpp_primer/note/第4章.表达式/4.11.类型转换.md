# 4.11 类型转换
### 何时发生隐式类型转换
* 在大多数表达式中，比`int`类型小的整型值首先提升为较大的整数类型。
* 在条件中，非布尔值转换成布尔类型。
* 在初始化过程中，初始值转换成变量的类型；在赋值语句中，右值运算对象转换成左侧运算对象的类型。
* 如果算术运算或关系运算的运算对象有多种类型，需要转换成同一种类型。
* 函数调用时会发生类型转换。
## 4.11.1 算术转换
**算术转换**的定义是把一种算术类型转换成另一种算术类型。算术转换过程中，运算符的运算对象将转换成最宽的类型，当表达式中既有浮点类型也有整数类型时，整数值将转换成相应的浮点类型<br>
### 整型提升
**整型提升**负责把小整数类型转换成较大的整数类型。<br>
### 无符号类型的运算对象
如果运算符的某个运算对象是无符号类型：<br>
首先执行整型提升。如果结果的类型匹配，无须进一步转换。如果两个（提升后的）运算对象的类型要么都是带符号的、要么都是无符号的，则小类型的运算对象转换成较大的类型。<br>
如果一个运算对象是无符号类型、另外一个运算对象是带符号类型，且其中无符号类型不小于带符号类型，那么带符号的运算对象转换成无符号类型。<br>
如果带符号类型大于无符号类型，此时转换的结果依赖于机器。如果无符号类型的所有值都能存在该带符号类型中，则无符号类型的运算对象转换成带符号类型。如果不能，那么带符号类型的运算对象转换成无符号类型。<br>
## 4.11.2 其他隐式类型转换
**数组转换成指针**：在大多数用到数组的表达式中，数组自动转换成指向数组首元素的指针，当数组被用作`decltype`关键字的参数，或者作为取地址符&、`sizeof`及`typeid`等运算符的运算对象时，该转换不会发生。如果用一个引用来初始化数组，该转换也不会发生。<br>
**指针的转换**：常量整数值`0`或者字面值`nullptr`能转换成任意指针类型；指向任意非常量的指针能转换成`void*`；指向任意对象的指针能转换成`const void*`。<br>
**转换成布尔类型**：如果指针或算术类型的值为0，转换结果是`false`；否则是`true`。<br>
**转换成常量**：允许将指向非常量类型的指针转换成指向相应的常量类型的指针，引用也是如此。但相反的转换不允许。<br>
**类类型定义的转换**：类类型能定义由编译器自动执行的转换，但是编译器每次只能执行一种类型的转换。<br>
## 4.11.3 显示转换
### static_cast
任何具有明确定义的类型转换，只要不包含底层`const`，都可以使用`static_cast`。<br>
### const_cast
`const_cast`只能改变运算对象的底层`const`，也只有`const_cast`能改变表达式的常量属性。<br>
### reinterpret_cast
`reinterpret_cast`通常为运算对象的位模式提供较低层次上的重新解释。<br>
例如：
```c++
int *ip;
char *pc = reinterpret_cast<char*>(ip);
```
此时，pc所指的真实对象是一个int而非字符，如果把pc当成普通字符指针使用可能发生错误。<br>