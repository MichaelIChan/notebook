# 10.2 初识泛型算法
## 10.2.1 只读算法
`accumulate`函数定义在头文件`numeric`中，接受三个参数，前两个指出了需要求和的元素的范围，第三个参数是和的初值：
```c++
// 对vec中的元素求和，和的初值是0
int sum = accumulate(vec.cbegin(), vec.cend(), 0);
```
```
Note:
accumulate的第三个参数的类型决定了函数中使用哪个加法运算符以及返回值的类型。
对于只读算法，通常最好使用cbegin()和cend()。
```
### 算法和元素类型
`accumulate`将第三个参数作为求和起点，这意味着，将元素类型加到和的类型上的操作必须是可行的。
### 操作两个序列的算法
`equal`用于确定两个序列是否保存相同的值。如果所有对应元素都相等，则返回`true`，否则返回`false`。此算法接受三个迭代器：前两个表示第一个序列中的元素范围，第三个表示第二个序列的首元素：
```c++
// roster2中的元素数目应该至少与roster1一样多
equal(roster1.cbegin(), roster1.cend(), roster2.cbegin());
```
由于`equal`利用迭代器完成操作，因此可以通过调用`equal`来比较两个不同类型的容器中的元素。而且，元素类型也不必一样，只要能用`==`来比较两个元素类型即可。<br>
```
Note:
只接受一个单一迭代器来表示第二个序列的算法，都假定第二个序列至少与第一个序列一样长。
```
## 10.2.2 写容器元素的算法
一些算法将新值赋予序列中的元素。当使用这类算法时，必须注意确保序列原大小至少不小于我们要求算法写入的元素的数目。算法不会执行容器操作，因此它们自身不可能改变容器的大小。<br>
fill算法接受一对迭代器表示一个范围，还接受一个值作为第三个参数，fill将给定的这个值赋予数据序列中的每个元素。<br>
```c++
// 将每个元素重置为0
fill(vec.begin(), vec.end(), 0);
```
### 算法不检查写操作
一些算法接受一个迭代器来指出一个单独的目的位置。这些算法将新值赋予一个序列中的元素，该序列从目的位置迭代器指向的元素开始。函数`fill_n`接受一个单迭代器、一个计数值和一个值。它将给定值赋予迭代器指向的元素开始的指定个元素。：
```c++
// 将所有元素重置为0
fill_n(vec.begin(), vec.size(), 0);
```
但是，在一个空容器上调用`fill_`n，其结果是未定义的。<br>
### 介绍 back_inserter
一种保证算法有足够元素空间来容纳输出数据的方法是使用插入迭代器。插入迭代器是一种向容器中添加元素的迭代器。通常情况下，当通过一个迭代器向容器元素赋值时，值被赋予迭代器指向的元素。当通过一个插入迭代器赋值时，一个与赋值号右侧值相等的元素被添加到容器中。<br>
`back_inserter`接受一个指向容器的引用，返回一个与该容器绑定的插入迭代器。当通过此迭代器赋值时，赋值运算符会调用`push_back`将一个具有给定值的元素添加到容器中：
```c++
vector<int> vec; // 空向量
auto it = back_inserter(vec); // 通过它赋值会将元素添加到vec中
*it = 42; // vec中现在有一个元素，值为42
```
常常用`back_inserter`来创建一个迭代器，作为算法的目的位置来使用：
```c++
// 添加10个元素到vec
fill_n(back_inserter(vec), 10, 0);
```
### 拷贝算法
`copy`算法接受三个迭代器，前两个表示一个输入范围，第三个表示目的序列的起始位置。传递给`copy`算法的目的序列至少要包含与输入序列一样多的元素。`copy`返回的是其目的位置迭代器的值。<br>
`replace`算法读入一个序列，并将其中所有等于给定值的元素都改为另一个值。此算法接受4个参数，前两个是迭代器，表示输入序列，后两个一个是要搜索的值，一个是新值：
```c++
// 将所有值为0的元素改为42
replace(ilst.begin(), ilst.end(), 0, 42);
```
如果希望保留原序列不变，可以调用`replace_copy`。此算法接受额外第三个迭代器参数，指出调整后序列的保存位置：
```c++
// 使用back_inserter按需要增长目标序列
replace_copy(ilst.cbegin(), ilst.cend(),
             back_inserter(ivec), 0, 42);
```
此调用后，`ilst`并未改变，`ivec`包含`ilst`的一份拷贝，原来在`ilst`中值为0的元素在`ivec`中都变为42。<br>
## 10.2.3 重排容器元素的算法
`sort`算法重排输入序列中的元素，使之有序，利用元素类型的<运算符来实现排序。<br>
`unique`算法重排输入序列，将相邻的重复项“消除”，并返回一个指向不重复值范围末尾的迭代器，`unique`并不真的删除任何元素，只是覆盖相邻的重复元素，使得不重复元素出现在序列开始部分。`unique`返回的迭代器指向最后一个不重复元素之后的位置。此位置之后的元素仍然存在，但不知道其具体值。<br>
```
Note:
标准库算法对迭代器而不是容器进行操作。因此算法不能直接添加或删除元素。
```